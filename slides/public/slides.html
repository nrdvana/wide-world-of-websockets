<!DOCTYPE html>
<head>
	<title>The Wide World of WebSockets</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="slides.css" />
	<script src="jquery-3.3.1.min.js"></script>
	<script src="slides.js"></script>
	<script src="chat.js"></script>
	<link rel="stylesheet" type="text/css" href="highlight/tomorrow-night.css" />
	<script src="highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script>
		$(document).ready(function() {
			window.slides.init();
			// autoconnect if page is not loaded as "slides.html", autoconnect
			if (!window.location.match('slides.html'))
				window.slides.reconnect();
		});
	</script>
</head>
<body>
<ol class="slides">

<li><h1>Test</h1>
	<ul class='auto-step'>
	<li>one
	<li>two
	<li>three
	</ul>

<li>
	<figure class='h'>
	<h1 class='loud'>Test</h1>
	</figure>

<li><h1>Wide World of WebSockets</h1>
	<div style="height:30pt"></div>
	<h2>A survey of the current state of<br> WebSockets in Perl 5</h2>
	<div style="height:30pt"></div>
	<h3>Michael Conrad<br>
	mike@nrdvana.net<br>
	CPAN: NERDVANA<br>
	</h3>
	<h5>https://github.com/nrdvana/wide-world-of-websockets/</h5>

<li><h2>Overview</h2>
	<ul class='auto-step'>
	<li>Purpose and Design of WebSockets
	<li>Problems solved with WebSockets
	<li>Event Driven Programming (in Perl 5)
	<li>Available Implementations (in Perl 5)
	<li>Conclusion and Recommendations
	</ul>

<li><h2>HTTP Request Lifecycle</h2>
	<figure>
	(image here)
	</figure>

	<pre class="notes">
	Familiar to most
	Client starts TCP
	Client requests resource
	Server responds
	</pre>

<li><h2>HTTP Long-poll</h2>
	<figure>
	(image here)
	</figure>

	<pre class="notes">
	Client starts request
	Server waits until it has something
	User sees spinner on browser
	What if server wants to send faster than client asks
	</pre>

<li><h2>WebSockets</h2>
	<figure>
	</figure>

	<pre class="notes">
    Starts as an HTTP(S) request
	Server responds with accept/decline
	Magic key isn't crypto, just cache busting
	Earlier versions did messy stuff; ignoring
    Changes protocol from command/response to peer-to-peer
    Messages are framed, not pure streams
    Remains within SSL-encapsulated connection
	</pre>

<li><h2>WebSockets</h2>
	<ul class='auto-step'>
	<li>Proposed in 2008
	<li>Revised several times up to 2012
	<li>Final version
		<table class='data' data-step='3-3'>
			<tr><th>Browser<th>Available Since</tr>
			<tr><td>IE 10<td>Win 8, Win7 on 2013-02</tr>
		    <tr><td>FireFox 11<td>2012-03</tr>
			<tr><td>Chrome 16<td>2011-12</tr>
			<tr><td>Safari 6<td>2012-07, OS X Mountain Lion</tr>
			<tr><td>Opera 12.10<td>2012-06</tr> 
			<tr><td>Android 4.4<td>2013-09</tr>
		</table>
	<li>https://github.com/gimite/web-socket-js
	</ul>

	<pre class="notes">
	Reaching sweet spot
	Most old phones gone
	Most old Macs gone
	Opera matters for Wii
	Flash workaround if you care
	</pre>

<li><h2>Example: Chat</h2>
	<figure class='chat-app'>
	</figure>

	<pre class="notes">
	Minimal delay on chat messages
	Most common example of websocket
	</pre>
<!--
<li><h2>Example: Stock Ticker / Notification</h2>

	<pre class="notes">
	Want to avoid lots of polling
	Want to see event as soon as it happens.
	</pre>
-->
<li><h2>Example: Watch presence of Client</h2>
	<figure class='client-monitor'>
	</figure>

	<pre class="notes">
	Server gets to choose how often to poll for presence of client
	Heavily loaded server will poll less.  If clients poll, server might go down.
	</pre>

<li><h2>Example: Intelligent File Upload</h2>

	https://webdeltasync.github.io/

	<pre class="notes">
	JavaScript can hash file locally
	only transfer new parts of file
	</pre>

<li><h2>Example: Mining BitCoin on Browsers</h2>

  (joke)

<li><h2>Example: Waiting for job in queue, and job progress</h2>

	<pre class="notes">
	400 in queue, up to 400 websockets listening.
	Each time back-end job starts, broadcast to web workers
	399 "new position" notifications go out
	1 connection gets progress updates until job complete
	</pre>

<li><h2>Example: iPad Apps</h2>

	<pre class="notes">
	iPad closed system, no perl
	can write web-apps
	event-driven is best model for UI
	</pre>

<li><h1>Event Driven Programming</h1>

  * POSIX event sources:
    * File handle read/write/error
    * Timers
    * Signals
  * Linux:
    * Inotify (file)
	* Netlink (file)
	* POSIX message queues (signal)
  * Windows
    * Thread/Window Message Queue
	* Some things *can't* cause events, and must block
  * Listen to all events at once

	<pre class="notes">
	quick version, entire talk of its own
	can't discuss using websockets without
	this background
	also helps to frame discussion
	</pre>

<li><h2>Event-driven: Popular Patterns</h2>
	<table>
	<tr><th>Blocking, Multi-Thread<th>Non-blocking, Event Loop
	<tr><td>
		<ul class="auto-step">
		<li>Classic blocking design:<br>
		    Kernel stops program while<br>
			waiting for one event.
		<li>Logical extension:<br>
		    Kernel stops thread while<br>
			waiting for one event.
		<li>Run one thread for each event<br>
			you are waiting on.
		</ul>
	<td>
		<ul class="auto-step">
		<li>Program makes a list of all<br>
			events it is waiting for.
		<li>Asks Kernel to wake it up when<br>
			an event is ready.
		</ul>
	</table>

	<pre class="notes">
	Event-driven usually refers to nonblocking event loop,
	but contrast with active polling like video game
	or realtime controls
	</pre>

<li><h2>Event-Driven: Pros/Cons</h2>
	<table data-step=1>
	<tr><th><th>Multi-Thread<th>Event Loop
	<tr><th data-step=2>Pros
		<td data-step=2>
			<ul>
			<li>Every event "ready to run"
			<li>Parallel processing
			<li>Follows natural pattern<br>of function calls
			</ul>
		<td data-step=4>
			<ul>
			<li>No segfaults or deadlocks
			<li>Scales to very large number<br>of <u>events</u>
			</ul>
	<tr><th data-step=3>Cons
		<td data-step=3>
			<ul>
			<li>Multi-thread Problems:<br>segfaults, deadlocks
			<li>Slow data structures
			<li>Development effort
			<li>One thread per event doesn't<br>scale well
			</ul>
		<td data-step=5>
			<ul>
			<li>No parallelism; every event<br>must process quickly
			<li>Must divide subroutines into<br>per-event pieces
			<li><b>Can't use blocking APIs</b>
			</ul>
	</table>

	<pre class="notes">
	as seen in Java
	blocking APIs: DBIC DNS
	
	Perl6 attempts fixing multithread
	Go attempts hybrid approach
	</pre>

<li>
  * Example of select-based loop
<li>
  * Event Loop
<li>
## Event Loop Back-Ends

  * LibEvent
  * LibEV
  * Gtk, Glib, etc
  * Mojo::Reactor
<li>
## Event Loop wrappers

### POE

  * Large back-compat, stable API
  * Lots of structure, helps organize references
  * Awkward
  * Less ecosystem activity

### AnyEvent

  * Clean minimalist API
  * Lots of callbacks, beware memory leaks
  * Popular ecosystem
  * Some past drama with author

### IO::Async

  * More structured than AnyEvent
  * Less awkward than POE

### Mojo::IOLoop

  * Also minimalist API
  * Only two options - pure perl or LibEV
  * Tailored toward web service, lacks general features
  * Mentioning it mostly because I refer to it again later

### Coro

  * Different approach to event linkage
  * Pretend that code is making blocking calls
  * Avoids excessive callbacks
  * Lots of "magic" behind the scenes

### Others


</ol>
</body>
</html>
