<!DOCTYPE html>
<head>
	<title>The Wide World of WebSockets</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="slides.css" />
	<script src="jquery-3.3.1.min.js"></script>
	<script src="slides.js"></script>
	<script src="chat.js"></script>
	<link rel="stylesheet" type="text/css" href="highlight/tomorrow-night.css" />
	<script src="highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script>
		$(document).ready(function() {
			window.slides.init();
			// autoconnect if page is not loaded as "slides.html", autoconnect
			if (!window.location.match('slides.html'))
				window.slides.reconnect();
		});
	</script>
</head>
<body>
<ol class="slides">

<li><h1>Test</h1>
	<ul class='auto-step'>
	<li>one
	<li>two
	<li>three
	</ul>

<li>
	<figure class='h'>
	<h1 class='loud'>Test</h1>
	</figure>

<li><h1>Wide World of WebSockets</h1>
	<div style="height:30pt"></div>
	<h2>A survey of the current state of<br> WebSockets in Perl 5</h2>
	<div style="height:30pt"></div>
	<h3>Michael Conrad<br>
	mike@nrdvana.net<br>
	CPAN: NERDVANA<br>
	</h3>
	<h5>https://github.com/nrdvana/wide-world-of-websockets/</h5>

<li><h2>Overview</h2>
	<ul class='auto-step'>
	<li>Purpose and Design of WebSockets
	<li>Problems solved with WebSockets
	<li>Event Driven Programming (in Perl 5)
	<li>Available Implementations (in Perl 5)
	<li>Conclusion and Recommendations
	</ul>

<li><h2>HTTP Request Lifecycle</h2>
	<figure>
	(image here)
	</figure>

	<pre class="notes">
	Familiar to most
	Client starts TCP
	Client requests resource
	Server responds
	</pre>

<li><h2>HTTP Long-poll</h2>
	<figure>
	(image here)
	</figure>

	<pre class="notes">
	Client starts request
	Server waits until it has something
	User sees spinner on browser
	What if server wants to send faster than client asks
	</pre>

<li><h2>WebSockets</h2>
	<figure>
	</figure>

	<pre class="notes">
    Starts as an HTTP(S) request
	Server responds with accept/decline
	Magic key isn't crypto, just cache busting
	Earlier versions did messy stuff; ignoring
    Changes protocol from command/response to peer-to-peer
    Messages are framed, not pure streams
    Remains within SSL-encapsulated connection
	</pre>

<li><h2>WebSockets</h2>
	<ul class='auto-step'>
	<li>Proposed in 2008
	<li>Revised several times up to 2012
	<li>Final version
		<table class='data' data-step='3-3'>
			<tr><th>Browser<th>Available Since</tr>
			<tr><td>IE 10<td>Win 8, Win7 on 2013-02</tr>
		    <tr><td>FireFox 11<td>2012-03</tr>
			<tr><td>Chrome 16<td>2011-12</tr>
			<tr><td>Safari 6<td>2012-07, OS X Mountain Lion</tr>
			<tr><td>Opera 12.10<td>2012-06</tr> 
			<tr><td>Android 4.4<td>2013-09</tr>
		</table>
	<li>https://github.com/gimite/web-socket-js
	</ul>

	<pre class="notes">
	Reaching sweet spot
	Most old phones gone
	Most old Macs gone
	Opera matters for Wii
	Flash workaround if you care
	</pre>

<li><h2>Example: Chat</h2>
	<figure class='chat-app'>
	</figure>

	<pre class="notes">
	Minimal delay on chat messages
	Most common example of websocket
	</pre>
<!--
<li><h2>Example: Stock Ticker / Notification</h2>

	<pre class="notes">
	Want to avoid lots of polling
	Want to see event as soon as it happens.
	</pre>
-->
<li><h2>Example: Watch presence of Client</h2>
	<figure class='client-monitor'>
	</figure>

	<pre class="notes">
	Server gets to choose how often to poll for presence of client
	Heavily loaded server will poll less.  If clients poll, server might go down.
	</pre>

<li><h2>Example: Intelligent File Upload</h2>

	https://webdeltasync.github.io/

	<pre class="notes">
	JavaScript can hash file locally
	only transfer new parts of file
	</pre>

<li><h2>Example: Mining BitCoin on Browsers</h2>

  (joke)

<li><h2>Example: Waiting for job in queue, and job progress</h2>

	<pre class="notes">
	400 in queue, up to 400 websockets listening.
	Each time back-end job starts, broadcast to web workers
	399 "new position" notifications go out
	1 connection gets progress updates until job complete
	</pre>

<li><h2>Example: iPad Apps</h2>

	<pre class="notes">
	iPad closed system, no perl
	can write web-apps
	event-driven is best model for UI
	</pre>

<li><h1>Event Driven Programming</h1>

  * POSIX event sources:
    * File handle read/write/error
    * Timers
    * Signals
  * Linux:
    * Inotify (file)
	* Netlink (file)
	* POSIX message queues (signal)
  * Windows
    * Thread/Window Message Queue
	* Some things *can't* cause events, and must block
  * Listen to all events at once

	<pre class="notes">
	quick version, entire talk of its own
	can't discuss using websockets without
	this background
	also helps to frame discussion
	</pre>

<li><h2>Event-driven: Popular Patterns</h2>
	<table>
	<tr><th>Blocking, Multi-Thread<th>Non-blocking, Event Loop
	<tr><td>
		<ul class="auto-step">
		<li>Classic blocking design:<br>
		    Kernel stops program while<br>
			waiting for one event.
		<li>Logical extension:<br>
		    Kernel stops thread while<br>
			waiting for one event.
		<li>Run one thread for each event<br>
			you are waiting on.
		</ul>
	<td><ul class="auto-step">
		<li>Program makes a list of all<br>
			events it is waiting for.
		<li>Asks Kernel to wake it up when<br>
			an event is ready.
		</ul>
	</table>

	<pre class="notes">
	Event-driven usually refers to nonblocking event loop,
	but contrast with active polling like video game
	or realtime controls
	</pre>

<li><h2>Event-Driven: Pros/Cons</h2>
	<table data-step=1>
	<tr><th><th>Multi-Thread<th>Event Loop
	<tr><th data-step=2>Pros
		<td data-step=2>
			<ul>
			<li>Every event "ready to run"
			<li>Parallel processing
			<li>Follows natural pattern<br>of function calls
			</ul>
		<td data-step=4>
			<ul>
			<li>No segfaults or deadlocks
			<li>Scales to very large number<br>of <u>events</u>
			</ul>
	<tr><th data-step=3>Cons
		<td data-step=3>
			<ul>
			<li>Multi-thread Problems:<br>segfaults, deadlocks
			<li>Slow data structures
			<li>Development effort
			<li>One thread per event doesn't<br>scale well
			</ul>
		<td data-step=5>
			<ul>
			<li>No parallelism; every event<br>must process quickly
			<li>Must divide subroutines into<br>per-event pieces
			<li><b>Can't use blocking APIs</b>
			</ul>
	</table>

	<pre class="notes">
	as seen in Java
	blocking APIs: DBIC DNS
	
	Perl6 attempts fixing multithread
	Go attempts hybrid approach
	</pre>

<li><h2>Natural Function Calls</h2>
	<figure>
	(animated image where function calls are shown as sideways tree)
	</figure>
	
	<pre class="notes">
	In code acting as "functions", call with
	arguments and return result
	function finishes calc before return
	</pre>

<li><h2>Event Loop Function Fragments</h2>
	<figure>
	(animated image where functions link events to next fragment)
	</figure>
	
	<pre class="notes">
	In eventloop pattern, functions must return to loop
	each fragment must set up event
	to trigger next fragment
	</pre>

<li><h2>Event Loop Basics</h2>
	<h3>Event Types (unix):</h3>
	<ul class="auto-step">
	<li>I/O (read, close, write, accept, inotify)
	<li>Signals (exit, reset, collect child process)
	<li>Time
	</ul>

	<pre class="notes">
	Unix has these needs
	Windows has additional things like MQ
	   Reaping threads, overlapped IO
	</pre>

<li><h2>Event Loop Basics</h2>
	<h3>Implementation</h3>
	<figure>
	(scrolling animation of select() and surrounding code)
	</figure>

	<pre class="notes">
	clearly bit of a mess
	especially details like signals
	want to wrap that in a library
	</pre>

<li><h2>Event Loop Implementations</h2>
	<ul>
	<li>LibEV
	<li>Gtk
	<li>Glib
	<li>...etc
	</ul>

	<pre class="notes">
	Lots to choose from
	LibEV particularly good
	But There Can Be Only One
	Need to adapt modules to any event loop
	</pre>

<li><h2>Event Loop Wrappers</h2>
	<h3>POE</h3>
	<ul>
	<li>Large back-compat, stable API
	<li>Lots of structure, helps organize references
	<li>Awkward / learning curve
	<li>Less ecosystem activity
	</ul>

<li><figure>
	(POE code)
	</figure>

<li><h2>Event Loop Wrappers</h2>
	<h3>AnyEvent</h3>
	<ul>
	<li>Clean minimalist API
	<li>Lots of callbacks, beware memory leaks
	<li>Popular ecosystem
	<li>Associated with drama
	</ul>

<li><figure>
	(AnyEvent code)
	</figure>

<li><h2>Event Loop Wrappers</h2>
	<h3>IO::Async</h3>
	<ul>
	<li>More structured than AnyEvent
	<li>Less awkward than POE
	<li>Home for drama refugees
	</ul>

<li><figure>
	(IO::Async code)
	</figure>

</ol>
</body>
</html>
